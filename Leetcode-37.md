# Leetcode 37.解数独 (Ubisoft UGP 2022笔试一测变体)

编写一个程序，通过填充空格来解决数独问题。

数独的解法需**遵循**如下规则：

数字 `1-9` 在**每一行**只能出现一次。
数字 `1-9` 在**每一列**只能出现一次。
数字 `1-9` 在每一个以粗实线分隔的 `3x3` 宫内只能出现一次。（请参考示例图）
数独部分空格内已填入了数字，空白格用 `.` 表示。

**示例 1**：

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/04/12/250px-sudoku-by-l2g-20050714svg.png)

```
输入：board = 
[["5","3",".",".","7",".",".",".","."],
["6",".",".","1","9","5",".",".","."],
[".","9","8",".",".",".",".","6","."],
["8",".",".",".","6",".",".",".","3"],
["4",".",".","8",".","3",".",".","1"],
["7",".",".",".","2",".",".",".","6"],
[".","6",".",".",".",".","2","8","."],
[".",".",".","4","1","9",".",".","5"],
[".",".",".",".","8",".",".","7","9"]]
输出：
[["5","3","4","6","7","8","9","1","2"],
["6","7","2","1","9","5","3","4","8"],
["1","9","8","3","4","2","5","6","7"],
["8","5","9","7","6","1","4","2","3"],
["4","2","6","8","5","3","7","9","1"],
["7","1","3","9","2","4","8","5","6"],
["9","6","1","5","3","7","2","8","4"],
["2","8","7","4","1","9","6","3","5"],
["3","4","5","2","8","6","1","7","9"]]
```
>输入的数独如上图所示，唯一有效的解决方案如下所示：
![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/04/12/250px-sudoku-by-l2g-20050714_solutionsvg.png)

**提示**：

>board.length == 9
>board[i].length == 9
>board[i][j] 是一位数字（1-9）或者 '.'
>题目数据 **保证** 输入数独仅有一个解.


## 解法 - 位运算+回溯：

数 $b$ 的二进制表示的第 $i$ 位（从低到高，最低位为第 0 位）为 $1$，当且仅当数字 $i+1$ 已经出现过。例如当 $b$ 的二进制表示为 $(011000100)_2$ 时，就表示数字 $3$，$7$，$8$ 已经出现过。

位运算有一些基础的使用技巧。下面列举了所有在代码中使用到的技巧：

对于第 $i$ 行第 $j$ 列的位置，$\textit{line}[i] ~|~ \textit{column}[j] ~|~ \textit{block}[\lfloor i/3 \rfloor][\lfloor j/3 \rfloor]$ 中第 $k$ 位为 $1$，表示该位置不能填入数字 $k+1$（因为已经出现过），其中 | 表示按位或运算。如果我们对这个值进行 $\sim$ 按位取反运算，那么第 $k$ 位为 1 就表示该位置可以填入数字 $k+1$，我们就可以通过寻找 $1$ 来进行枚举。由于在进行按位取反运算后，这个数的高位也全部变成了 $1$，而这是我们不应当枚举到的，因此我们需要将这个数和 $(111111111)_2 = (\text{1FF})_{16}$
​
  进行按位与运算 $\&$，将所有无关的位置为 $0$；

我们可以使用按位异或运算 $\wedge$，将第 $i$ 位从 $0$ 变为 $1$，或从 $1$ 变为 $0$。具体地，与数 $1 << i$ 进行按位异或运算即可，其中 $<<$ 表示左移运算；

我们可以用 $b ~\&~ (-b)$ 得到 $b$ 二进制表示中最低位的 1，这是因为 $(−b)$ 在计算机中以补码的形式存储，它等于 $\sim b + 1$。$b$ 如果和 $\sim b$ 进行按位与运算，那么会得到 $0$，但是当 $\sim b$ 增加 $1$ 之后，最低位的连续的 $1$ 都变为 $0$，而最低位的 $0$ 变为 $1$，对应到 $b$ 中即为最低位的 $1$，因此当 $b$ 和 $\sim b + 1$ 进行按位与运算时，只有最低位的 $1$ 会被保留；

当我们得到这个最低位的 $1$ 时，我们可以通过一些语言自带的函数得到这个最低位的 $1$ 究竟是第几位（即 $i$ 值），具体可以参考下面的代码；

我们可以用 $b$ 和最低位的 $1$ 进行按位异或运算，就可以将其从 $b$ 中去除，这样就可以枚举下一个 $1$。同样地，我们也可以用 $b$ 和 $b−1$ 进行按位与运算达到相同的效果。

## 代码：

```cpp
class Solution {
private:
    int line[9];
    int column[9];
    int block[3][3];
    bool valid;
    vector<pair<int, int>> spaces;

public:
    void flip(int i, int j, int digit) {
        line[i] ^= (1 << digit);
        column[j] ^= (1 << digit);
        block[i / 3][j / 3] ^= (1 << digit);
    }

    void dfs(vector<vector<char>>& board, int pos) {
        if (pos == spaces.size()) {
            valid = true;
            return;
        }

        auto [i, j] = spaces[pos];
        int mask = ~(line[i] | column[j] | block[i / 3][j / 3]) & 0x1ff;
        for (; mask && !valid; mask &= (mask - 1)) {
            int digitMask = mask & (-mask);
            int digit = __builtin_ctz(digitMask);
            flip(i, j, digit);
            board[i][j] = digit + '0' + 1;
            dfs(board, pos + 1);
            flip(i, j, digit);
        }
    }

    void solveSudoku(vector<vector<char>>& board) {
        memset(line, 0, sizeof(line));
        memset(column, 0, sizeof(column));
        memset(block, 0, sizeof(block));
        valid = false;

        for (int i = 0; i < 9; ++i) {
            for (int j = 0; j < 9; ++j) {
                if (board[i][j] == '.') {
                    spaces.emplace_back(i, j);
                }
                else {
                    int digit = board[i][j] - '0' - 1;
                    flip(i, j, digit);
                }
            }
        }

        dfs(board, 0);
    }
};
```

