# 面试题 01.01. 判定字符是否唯一

### 解题思路
` unordered_set `容器，和` set `容器很像，唯一的区别就在于` set `容器会自行对存储的数据进行排序，而` unordered_set `容器不会。
它有以下特性：
***1. 不再以键值对的形式存储数据，而是直接存储数据的值。
2. 容器内部存储的各个元素的值都互不相等，且不能被修改。
3. 不会对内部存储的数据进行排序（这和该容器底层采用哈希表结构存储数据有关，日后有空再谈）。***

那么这个`unordered_set`容器也会包含很多成员方法。我们今天需要用到的是`count(key)`和`emplace(key)`

需要进行的操作：
1. 遍历字符串内的元素（字符），把它放到`unordered_set<char>`容器里。
2. 当`count(key)`的结果大于`0`，说明容器里已经存在该元素，停止遍历，返回`false`（只要有重复就不是唯一字符了对吧）
3. 如果所有字符都顺利遍历完没有被打断，说明所有字符都是唯一的。返回`true`

虽然有其他解法，但是我还是喜欢用STL偷个懒（沙发瘫）就像我盼望哪家面试我的时候只问一个简单的反转链表一样...
### 代码

```cpp
class Solution {
public:
    bool isUnique(string astr) {
        unordered_set<char> temp;
        for(int i = 0 ; i < astr.size();i++)
        {
            if(temp.count(astr[i]))
            {
                return false;
            }
            temp.emplace(astr[i]);
        }
        return true;
    }
};
```
### 拓展：unordered_set内置方法：

| 成员方法 |	功能 |
| :---- | :---- |
| `begin()`	|返回**指向容器**中**第一个元素**的正向迭代器。|
| `end();`	|返回**指向容器**中**末尾元素**之后位置的正向迭代器。|
|`cbegin()`	|和` begin() `功能相同，只不过其返回的是` const `类型的正向迭代器。|
|`cend()`	|和` end() `功能相同，只不过其返回的是` const `类型的正向迭代器。
|`empty()`	|若容器为**空**，则返回`true`；否则返回`false`。
|`size()`	|返回**当前容器**中存有**元素的个数**。
|`max_size()`	|返回容器所能**容纳元素的最大个数**，不同的操作系统，其返回值可能不相同。
|`find(key)`	|查找以值为` key `的元素，如果找到，则返回一个**指向该元素的正向迭代器**；反之，则返回一个**指向容器中最后一个元素之后位置的迭代器**。
|`count(key)`	|在容器中**查找**值为` key `的元素的个数。
|`equal_range(key)`	|返回一个` pair `对象，其包含**2个迭代器**，用于表明当前容器中值为` key `的元素所在的范围。
|`emplace()`	|向容器中**添加**新元素，效率比` insert() `方法高。
|`emplace_hint()	`|向容器中**添加**新元素，效率比` insert() `方法高。
|`insert()`	|向容器中**添加**新元素。
|`erase()`	|**删除**指定元素。
|`clear()`	|**清空容器**，即删除容器中存储的所有元素。
|`swap()`	|**交换** 2 个` unordered_map `容器存储的元素，前提是必须保证这 2 个容器的**类型完全相等**。
|`bucket_count()`	|返回当前容器**底层存储元素**时，使用**桶**（一个线性链表代表一个桶）的数量。
|`max_bucket_count()`	|返回当前系统中，unordered_map 容器底层**最多**可以使用多少桶。
|`bucket_size(n)`	|返回第` n `个桶中存储元素的**数量**。
|`bucket(key)`	|返回值为` key `的元素所在桶的**编号**。
|`load_factor()`	|返回` unordered_map `容器中当前的负载因子。负载因子，指的是的当前容器中存储元素的数量（size()）和使用桶数（bucket_count()）的比值，即``` load_factor() = size() / bucket_count()```。|
|`max_load_factor()`	|返回或者设置当前` unordered_map `容器的负载因子。
|`rehash(n)`	|将当前容器底层使用桶的数量设置为`n`。
|`reserve()`	|将存储桶的数量（也就是` bucket_count() `方法的返回值）设置为至少容纳`count`个元（不超过最大负载因子）所需的数量，并**重新整理容器**。
|`hash_function()`	|返回当前容器使用的**哈希函数对象**。
